import re, sys, requests, json, subprocess, os
import numpy as np
PUNCTUATION = (".", "?", "!")
PUNCTUATION_PROBS = (0.7, 0.25, 0.05)
commands_regex = re.compile("(a|b|up|down|left|right|start)$", re.IGNORECASE)
POKEYELLOW_DIR = "C:/tpp/hacksrc/yellow"

triples = {}

def load_emotes(url = 'https://api.twitch.tv/kraken/chat/twitchplayspokemon/emoticons'):
    # load emotes from the given url
    # expects the Twitch API format, will break on anything else
    emotes_succeeded = False
    emotes_tries = 0
    while not emotes_succeeded:
        try:
            response = requests.get(url)
            if response.status_code != 200:
                raise requests.HTTPError
            emotes_succeeded = True
        except:
            emotes_tries += 1
            if emotes_tries >= 3:
                raise Exception("Failed to compile emotes list")
    emotelist = [x['regex'] for x in response.json()['emoticons']]
    emote_regex = re.compile(r"\b(" + "|".join(emotelist) + r")\b")
    return emote_regex

def get_charmap(filename):
    # input is the path to the repository's charmap
    # output is a dict charmap and a compiled regex charmap_re
    charmap = {}
    with open(filename, encoding='ascii', errors='ignore') as F:
        for line in F.readlines():
            if not line.startswith("charmap"): continue
            args = re.split(", *\$", line.split(" ", 1)[1])
            key = args[0].split("\"")[1]
            if len(key) == 0:
                continue
            value = bytes.fromhex(hex(int(args[1].split(' ')[0].strip(), 16))[2:])
            charmap[key] = value
    L = list(charmap.keys())
    L.sort(key = len, reverse = True)
    charmap_re_pattern = "(" + "|".join([re.escape(x) for x in L]) + ")"
    charmap_re = re.compile(charmap_re_pattern)
    return charmap, charmap_re

class RWMC:
    def __init__(self, emotes_url = 'https://api.twitch.tv/kraken/chat/twitchplayspokemon/emoticons', charmap_file = os.path.join(POKEYELLOW_DIR, "charmap.asm")):
        self.emote_regex = load_emotes(url = emotes_url)
        self.triples = {}
        self.charmap, self.charmap_re = get_charmap(charmap_file)
        self.num_lines = 0

    def train_line(self, line):
        # clean the line
        clean_line = line.decode().strip()
        # remove Kappa and friends
        clean_line = self.emote_regex.sub("", clean_line).strip()
        # collapse spaces
        clean_line = re.sub(" {2,}", " ", clean_line)
        # don't process an empty line
        if len(clean_line) == 0:
            return
        # don't process a TPP command
        if clean_line.startswith("!") or commands_regex.match(clean_line):
            return
        self.num_lines += 1
        # append random punctuation if needed
        if clean_line[-1] not in PUNCTUATION:
            clean_line += np.random.choice(PUNCTUATION, p = PUNCTUATION_PROBS)
        # process the line into the dictionary of triples
        words = ["", ""] + clean_line.split() + ["", ""]
        for i in range(len(words) - 2):
            cur_key = (words[i], words[i + 1])
            if cur_key in self.triples:
                self.triples[cur_key].append(words[i+2])
            else:
                self.triples[cur_key] = [words[i+2]]

    def build_chain(self, min_len, max_len):
        # Sentence start and end state is two empty strings
        construction = ["", ""]
        cur_key = ("", "")
        chain = ""
        # Iterate until you have a long-enough sentence.
        while True:
            if cur_key in triples:
                construction.append(np.random.choice(triples[cur_key])) # Continue the current sentence.
            else:
                construction = ["", ""] # Reseed the current sentence.
            cur_key = (construction[-2], construction[-1])
            if cur_key == ("", "") and len(construction) > 2:
                sentence = " ".join(construction).strip()
                if len(chain + " " + sentence) <= max_len:
                    chain += " " + sentence
                    chain = chain.strip()
                if len(chain) > min_len:
                    return chain
                construction = ["", ""]

    def chain2bytes(self, chain):
        # input: chain is a string generated by rwmc
        # output: byte string to send to lua
        # specifications: first line is 18 chars,
        #     subsequent lines are 17 chars
        lines = []
        cur_line = b"\x00" # text
        cur_line_length = 0
        words = chain.split()
        num_lines = 0
        eos = False
        for word in words:
            delta_len = len(word)
            if re.search("[\.\?!]$", word):
                eos = True
            if cur_line_length > 0: # line is not empty, add a space
                delta_len += 1
            if cur_line_length + delta_len > 18 - (len(lines) > 0): # next line
                lines.append(cur_line)
                num_lines += 1
                if num_lines == 1:
                    cur_line = b"\x4f" # line
                else:
                    cur_line = b"\x55" # cont
                cur_line_length = 0
            if cur_line_length >= 1:
                cur_line += b"\x7f" # space
                cur_line_length += 1
            while word:
                M = self.charmap_re.match(word)
                if M:
                    key = M.group(1)
                    if key == "#":
                        cur_line_length += 4
                    elif key == "<pkmn>":
                        cur_line_length += 2
                    elif key in ["<PLAYER>", "<RIVAL>"]:
                        cur_line_length += 8
                    else:
                        if key in ["<USER>", "<TARGET>", "@"]:
                            key = "?"
                        cur_line_length += 1
                else:
                    key = "?"
                    cur_line_length += 1
                cur_line += self.charmap[key]
                word = word[len(key):]
            if eos:
                num_lines = 0
                lines.append(cur_line)
                cur_line = b"\x51" # para
                cur_line_length = 0
                eos = False
        if cur_line == b"\x51":
            cur_line = b""
        lines.append(cur_line)
        return b"".join(lines)
